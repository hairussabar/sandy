package sandy.core.data.haxe {
	import flash.utils.Dictionary;

	/**
	 * Classbased on haxe autogenerated crap, fixed to conform to haxe specs.
	 * @see http://haxe.org/api/hash
	 * @author makc.
	 */
	public class Hash {
		public function Hash() : void {
			this.h = new flash.utils.Dictionary();
		}
		
		protected var h : flash.utils.Dictionary;
		public function set(key : String,value : *) : void {
			this.h[key] = value;
		}
		
		public function get(key : String) : * {
			return this.h[key];
		}
		
		public function exists(key : String) : Boolean {
			return (this.h[key] != undefined);
		}
		
		public function remove(key : String) : Boolean {
			if (exists (key)) {
				delete(this.h[key]);
				return true;
			}
			return false;
		}
		
		public function keys() : * {
			var $r : * = new Dictionary;
			for(var $k : String in this.h) $r[$k] = $k; // FIXME what keys haxe has here?
			return new Iterator ($r);
		}
		
		public function iterator() : * {
			return new Iterator (h);
		}
		
		public function toString() : String {
			var s : StringBuf = new StringBuf();
			s.add("{");
			var it : * = this.keys();
			{ var $it : * = it;
			while( $it.hasNext() ) { var i : String = $it.next();
			{
				s.add(i);
				s.add(" => ");
				s.add(Std.string(this.get(i)));
				if(it.hasNext()) s.add(", ");
			}
			}}
			s.add("}");
			return s.toString();
		}
		
	}
}
